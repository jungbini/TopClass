  Changes ClosureRewriteModule desugaring to allow inner class declaration before outer class. IE goog.module("foo.bar.Outer.Inner"); before goog.module("foo.bar.Outer");  Some of the major implementation points: - instead of creating a goog.scope() rename every top level name in a module with a module$contents$Foo_ prefix to guarrantee uniqueness - for goog.module()s rename the exports object to module$exports$Foo for global uniqueness - rewrite all goog.require()s that reference a goog.module() (even inside of legacy scripts) to pull in the relevant module$exports$Foo object. - inline all type aliases (both from goog.require()s and goog.forwardDeclare()s) in goog.module() files because goog.scope() did this and other passes have come to depend on it - if a goog.module() declares legacy namespace add a "foo.Bar = module$exports$foo$Bar;" binary name to legacy name bridge at the end so that legacy goog.require()s resolve - for every legacy script add a "var module$exports$foo$Bar = foo.Bar;" legacy name to binary name bridge at the end so that all goog.require() statements inside of goog.module() files can be desugared with the assumption that there is a binary name out there for it to reference - replace JsDoc type names in the entire program to turn fully qualified type names that reference types in goog.module() files into resolvable "module$contents$Foo" references, as well as to account for type alias inlining in goog.module() file.  Fixes https://github.com/google/closure-compiler/issues/1264 ------------- Created by MOE: https://github.com/google/moe MOE_MIGRATED_REVID=118622849  