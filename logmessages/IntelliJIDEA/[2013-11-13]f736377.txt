those which were not shown on the graph (i.e. if branch filtering was active), and then apply details filter to them.  There were two problems with this approach: 1. In a multi-root project top-commits were formed correctly (e.g. last 2000 commits in 2 repositories), but commit details cache was populated only with the last 1000 for each repository, i.e. for some commits there were no details available if repositories didn't grow evenly (e.g. if one repository is contributed more often than the other, last 2000 commits of the compound log can be occupied by 1900 commits from one repo, and only 100 from another). Such commits were just skipped, which led to "holes" in filtered results. 2. To be able to determine if a commit is visible on the graph or not, we should have either found a node for the commit (which is slow), or store a map of nodes to hashes (which occupies memory).  SOLUTION: 1. Take commit details from the CommitDetailsGetter which would load missing details if needed. 2. Instead of using top-commits list and managing node-to-hash map, walk down the filtered graph.  TODO (will be fixed soon): * Top commit details cache is still populated incompletely in case of multi-root projects. Solving this issue would eliminate the need of requesting VCS via CommitDataGetter. * Top commit list is not needed anymore and can be removed to simplify internal structure and save memory.  