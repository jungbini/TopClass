  ID allocation race fix for OCKVS stores  Formerly, the ID allocator would write a column to its backing store, wait a little while, and then read the entire row containing the column it just wrote.  The ID allocator then decided whether it succeeded by checking whether the lexicographically last column on the row was the one it just wrote.  This created a potential to enter the the following (racy) livelock:  A starts loop, reads partition row, gets latest counter C A writes column claiming C+1 B reads partition row, gets latest counter C+1 B writes column claiming C+2 A starts verification, reads partition row, gets latest counter C+2 from B A determines that it failed, since B's C+2 comes after its C+1 A starts loop, reads partition row, gets latest counter C+2 again A writes column claiming C+3 B starts verification, reads partition row, gets latest counter C+3 from A B determines that it failed, since A's C+3 comes after its C+2 B starts loop, reads partition row, gets latest counter C+3 again B writes column claiming C+4 ... and so on to failure by exceeding maximum retries  The ID allocator now avoids this by reading just a slice of the partition row, instead of the whole partition row, during verification; the slice contains only those columns that start with the targeted counter value.  This prevents an ID allocator from seeing claims for counter values higher than the one it is currently attemting to grab.  Like the rest of the current ID allocation implementation, this is OK for fixed-size and fixed-offset blocks (I think) but would be incorrect for variable block sizes.  We don't implement variable block sizes yet in the ID allocator, so this is not a material concern right now.  This change is just a few lines, but the code is delicate.  All the InternalCassandra* and InternalAstyanax* tests pass on my machine with this change, but it is otherwise untested.  